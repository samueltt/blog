为什么使用事物？

1.数据完整性

2.数据安全性

3.充分利用系统资源，提高系统并发处理的能力


1. 事务的特征

事务具有四个特性：原子性（Atomiocity）、一致性（Consistency）、隔离性（Isolation）和持久性（Durability），这四个特性简称ACID特性。

1.1原子性

事务是数据库的逻辑工作单位，事务中包括的所有操作要么都做，要么都不做。

1.2 一致性

事务执行的结果必须是使数据库从一个一致性的状态变到另外一个一致性状态。

1.3 隔离性

一个事务的执行不能被其他事务干扰。即一个事务内部的操作及使用的数据对其他

事务是隔离的，并发执行的各个事务之间互相不干扰。

1.4 持久性

一个事务一旦成功提交，对数据库中数据的修改就是持久性的。接下来其他的其他

操作或故障不应该对其执行结果有任何影响。

```
READ UNCOMMITTED(未提交)
即使没有提交，对其它事务也可见。未提交的数据会引起脏读(Dirty Read)。
测试流程：
1、A设置read-uncommitted, start transaction
2、B执行start transaction，修改一条记录，
3、A查询记录，得到了以为正确的记录
4、B回滚。
问题：A读到了B没有提交的记录，也就是脏读。 

READ COMMITTED(提交读)
一个从开始直到提交之前所做的任何修改对其它事务都是不可见的。两次同样的查询可能会得到不一样的结果，称为不可重复读(nonrepeatable read)
测试流程：
1、A设置read-committed, start transaction
2、B执行start transaction，修改一条记录，查询记录，记录已经修改成功
3、A查询记录，结果还是老的记录
4、B提交事务
5、A再次查询记录，结果是新的记录。
问题：两次查询结果不一致，也就是不可重复读问题。

REPEATABLE READ(可重复读)-MySQL默认的事务隔离级别
保证了在同一事务中多次读取结果是一致的。但会引起另外一个幻读问题，当某个事务在读取某个范围记录时，另外一个事务在该范围插入和新记录，当之前事务再次读取该范围记录时会产生幻行。
测试流程：
1、A设置repeatable-read, start transaction，查询记录，结果是老的记录
2、B执行start transaction，修改一条记录，查询记录，记录已经修改成功
3、A查询记录，结果还是老的记录
4、B提交事务
5、A再次查询记录，结果还是老的记录。
问题：可以重复读，A在事务过程中，即使B修改了数据，并且commit，A读取的还是老的数据。即可重复读。
注意：这里可能会存在一个新的问题，A在事务过程中，B增加一条记录，并提交，导致A的两次读取不一致，会多一条记录，也就是幻影读。InnoDB通过多版本并发控制(MVCC)解决了幻读问题。

SERIALIZABLE(可串行化)
强制事务串行执行，但可能导致大量超时和锁争问题。
测试流程：
1、A设置serializable, start transaction，查询记录，结果是老的记录
2、B执行start transaction，修改一条记录，B卡在这里，要等待A完成才行。
3、A查询记录，结果还是老的记录，A提交。
4、B的修改操作才进行下去。
注意：B在等待过程中，会出现lock超时。
```
